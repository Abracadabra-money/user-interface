<template>
  <div class="deposit-borrow-block">
    <h3 v-if="actionType === 'borrow'">Deposit collateral</h3>
    <h3 v-if="actionType === 'repay'">Repay {{ tokenPairName }}</h3>

    <div class="checkbox-wrap" v-if="this.tokenName === 'WAVAX'">
      <div class="box-wrap" @click="toggleUseAVAX" :class="{ active: useAVAX }">
        <div class="checkbox" v-if="useAVAX">
          <img
            class="checkbox-checked"
            src="@/assets/images/checkboxChecked.svg"
            alt=""
          />
        </div>
        <div class="checkbox" v-else>
          <img src="@/assets/images/checkbox.svg" alt="" />
        </div>
      </div>
      <p class="label-text" @click="toggleUseAVAX">Use AVAX</p>
    </div>

    <div class="input-wrap">
      <ValueInput
        :max="maxMainValue"
        @onchange="updateMainValue"
        :parentValue="mainValue"
        :error="mainValueError"
        :valueName="mainValueTokenName"
      />
    </div>

    <h3 v-if="actionType === 'borrow'">Borrow {{ tokenPairName }}</h3>
    <h3 v-if="actionType === 'repay'">Remove collateral</h3>

    <div class="input-wrap">
      <ValueInput
        :max="maxValueAmount"
        :showMax="showMax"
        :valueName="pairValueTokenName"
        @onchange="updatePairValue"
        :parentValue="pairValue"
        :error="pairValueError"
      />
    </div>

    <div class="estimate-box">
      <EstimationBlock
          :liquidityPrice="liquidationPrice"
          :nxusdAmount="this.pairValue"
          @onchange="updatePercentValue"
          :maxValue="ltv"
          :value="percentValue"
          :pool="pool"
          :tokentToNUSD="tokentToNUSD"
      />
    </div>

    <div class="config-box" v-if="actionType === 'borrow'">
      <LiquidationRules
        :liquidationPrice="liquidationPrice"
        @onchange="updatePercentValue"
        :maxValue="ltv"
        :value="percentValue"
      />
    </div>

<!--    <div class="config-box" v-if="actionType === 'borrow'">-->
<!--      <div class="checkbox-wrap">-->
<!--        <div-->
<!--          class="box-wrap"-->
<!--          @click="toggleShowLeverage"-->
<!--          :class="{ active: showLeverage, disabled: !showLeverage }"-->
<!--        >-->
<!--          <div class="checkbox" v-if="showLeverage">-->
<!--            <img-->
<!--              class="checkbox-checked"-->
<!--              src="@/assets/images/checkboxChecked.svg"-->
<!--              alt=""-->
<!--            />-->
<!--          </div>-->
<!--          <div class="checkbox" v-else>-->
<!--            <img src="@/assets/images/checkbox.svg" alt="" />-->
<!--          </div>-->
<!--        </div>-->
<!--        <p class="label-text" @click="toggleShowLeverage">Change leverage</p>-->

<!--        <img-->
<!--          src="@/assets/images/i-icon.svg"-->
<!--          alt=""-->
<!--          class="info-icon"-->
<!--          v-tooltip="-->
<!--            'Allows users to leverage their position. Read more about this in the documents!'-->
<!--          "-->
<!--        />-->
<!--      </div>-->

<!--      <template v-if="showLeverage">-->
<!--        <transition name="fade">-->
<!--          <SlipageBlock :slipage="slipage" @update="updateSlipage" />-->
<!--        </transition>-->
<!--        <transition name="fade">-->
<!--          <LeverageBar :multiplier="multiplier" @update="updateMultiplier" />-->
<!--        </transition>-->
<!--      </template>-->
<!--    </div>-->

    <div class="action-wrap">
      <div class="checkbox-wrap">
        <div
          class="box-wrap"
          @click="toggleUpdatePrice"
          :class="{ active: updatePrice }"
        >
          <div class="checkbox" v-if="updatePrice">
            <img
              class="checkbox-checked"
              src="@/assets/images/checkboxChecked.svg"
              alt=""
            />
          </div>
          <div class="checkbox" v-else>
            <img src="@/assets/images/checkbox.svg" alt="" />
          </div>
        </div>
        <p class="label-text" @click="toggleUpdatePrice">Update price</p>

        <img
          src="@/assets/images/i-icon.svg"
          alt=""
          class="info-icon"
          v-tooltip="
            'Update Collateral price from the oracle, for a small gas fee!'
          "
        />
      </div>

      <button
        class="btn action-btn"
        @click="actionHandler"
        :disabled="actionBtnText === 'Nothing to do'"
      >
        {{ actionBtnText }}
      </button>
    </div>
  </div>
</template>

<script>
const ValueInput = () => import("@/components/UiComponents/ValueInput");
const LiquidationRules = () => import("@/components/Pool/LiquidatonRules");
const LeverageBar = () => import("@/components/Pool/LeverageBar");
const EstimationBlock = () => import("@/components/Pool/EstimationBlock");
const SlipageBlock = () => import("@/components/Pool/SlipageBlock");

export default {
  props: {
    poolId: {
      required: true,
    },
    balance: {
      required: true,
    },
    balanceNativeToken: {
      required: false,
    },
    pairBalance: {
      require: true,
    },
    tokenName: {
      type: String,
      required: true,
    },
    tokenToUsd: {
      type: Number,
      default: 1,
    },
    tokenPairToUsd: {
      type: Number,
      default: 1,
    },
    tokenPairName: {
      type: String,
      required: true,
    },
    userTotalCollateral: {
      required: true,
    },
    userTotalBorrowed: {
      required: true,
    },
    actionType: {
      type: String,
      required: true,
    },
    tokenDecimals: {
      type: Number,
      required: true,
    },
    tokenPairDecimals: {
      type: Number,
      required: true,
    },
    ltv: {
      type: Number,
      required: true,
    },
    isUpdatePrice: {
      type: Boolean,
    },
    exchangeRate: {
      required: true,
    },
  },
  data() {
    return {
      inputData: false,
      userBalance: null,
      userBalanceNativeToken: null,

      mainValue: "",
      mainValueError: "",

      pairValue: "",
      pairValueError: "",

      percentValue: "",

      updatePrice: this.isUpdatePrice,

      multiplier: 1,
      slipage: 1,
      showLeverage: false,
    };
  },
  watch: {
    actionType() {
      this.clearData();
    },
  },
  computed: {
    pool() {
      const poolId = Number(this.$route.params.id);
      return this.$store.getters.getPoolById(poolId);
    },
    maxValueAmount() {
      const borrowedInDolarts =
        this.$store.getters.getUserBorrowPart(this.poolId) /
        this.tokenPairToUsd;
      const collateralInDolarts =
        this.$store.getters.getUserCollateralShare(this.poolId) /
        this.tokenToUsd;
      const userHasDolars = collateralInDolarts - borrowedInDolarts;

      let calcAmount;

      if (this.mainValue) {
        const borrowPercent =
          (this.mainValue /
            this.$store.getters.getUserBorrowPart(this.poolId)) *
          100;

        calcAmount = (this.maxPairValue * borrowPercent) / 100;
      } else {
        const acceptedPercent = (userHasDolars / collateralInDolarts) * 100;

        calcAmount = (this.maxPairValue * acceptedPercent) / 100;
      }

      return calcAmount;
    },
    useAVAX() {
      return this.$store.getters.getUseAVAX;
    },
    liquidationMultiplier() {
      return (200 - this.ltv) / 100;
    },
    showMax() {
      if (this.actionType === "borrow") return false;

      return true;
    },
    maxMainValue() {
      const balance = this.getAVAXStatus()
        ? this.$ethers.utils.formatEther(
            this.$store.getters.getBalanceNativeToken(this.poolId).toString()
          )
        : this.$ethers.utils.formatUnits(
            this.$store.getters.getBalanceToken(this.poolId).toString(),
            this.tokenDecimals
          );

      if (this.actionType === "borrow") return balance;
      if (this.actionType === "repay") {
        if (
          parseFloat(this.$store.getters.getUserBorrowPart(this.poolId)) >
          parseFloat(this.parsedPairBalance)
        )
          return this.parsedPairBalance;

        return this.$store.getters.getUserBorrowPart(this.poolId);
      }

      return 0;
    },
    mainValueTokenName() {
      const tokenSymbol = this.getAVAXStatus() ? "AVAX" : this.tokenName;
      if (this.actionType === "borrow") return tokenSymbol;
      if (this.actionType === "repay") return this.tokenPairName;

      return "XX";
    },
    pairValueTokenName() {
      const tokenSymbol = this.getAVAXStatus() ? "AVAX" : this.tokenName;
      if (this.actionType === "borrow") return this.tokenPairName;
      if (this.actionType === "repay") return tokenSymbol;

      return "XX";
    },
    pairValueDecimals() {
      if (this.actionType === "borrow") return this.tokenPairDecimals;
      if (this.actionType === "repay") return this.tokenDecimals;

      return 18;
    },
    mainValueDecimals() {
      if (this.actionType === "borrow") return this.tokenDecimals;
      if (this.actionType === "repay") return this.tokenPairDecimals;

      return 18;
    },
    parsedPairBalance() {
      return this.$ethers.utils.formatUnits(
        this.$store.getters.getBalancePairToken(this.poolId).toString(),
        this.tokenPairDecimals
      );
    },
    tokentToNUSD() {
      const tokenToNUSD = 1 / this.exchangeRate;
      // eslint-disable-next-line no-useless-escape
      let re = new RegExp(`^-?\\d+(?:\.\\d{0,` + (4 || -1) + `})?`);
      return tokenToNUSD.toString().match(re)[0];
    },
    maxPairValue() {
      if (this.actionType === "borrow") {
        let valueInDolars;
        let maxPairValue;

        if (this.mainValue) {
          valueInDolars = this.mainValue / this.tokenToUsd;
          maxPairValue = (valueInDolars / 100) * this.ltv;
        } else {
          valueInDolars =
            this.$store.getters.getUserCollateralShare(this.poolId) /
            this.tokenToUsd;
          maxPairValue =
            (valueInDolars / 100) * this.ltv -
            this.$store.getters.getUserBorrowPart(this.poolId);
        }

        return maxPairValue;
      }

      if (this.actionType === "repay") {
        const maxAmount = parseFloat(
          +this.$store.getters.getUserCollateralShare(this.poolId)
        ).toFixed(20);
        // .toLocaleString(
        //   "fullwide",
        //   {
        //     maximumFractionDigits: this.pairValueDecimals,
        //   }
        // );
        let re = new RegExp(
          // eslint-disable-next-line no-useless-escape
          `^-?\\d+(?:\.\\d{0,` + (this.pairValueDecimals || -1) + `})?`
        );
        return maxAmount.toString().match(re)[0];
      }

      return 0;
    },
    signer() {
      return this.$store.getters.getSigner;
    },
    actionBtnText() {
      if (this.mainValueError || this.pairValueError) return "Nothing to do";

      if (this.actionType === "borrow") {
        if (this.mainValue && this.pairValue && parseFloat(this.pairValue) > 0)
          return "Add collateral and borrow";

        if (this.mainValue) return "Add collateral";

        if (this.pairValue) return "Borrow";
      }

      if (this.actionType === "repay") {
        if (this.mainValue && this.pairValue && parseFloat(this.pairValue) > 0)
          return "Remove collateral and repay";

        if (this.mainValue) return "Repay";

        if (this.pairValue) return "Remove collateral";
      }

      return "Nothing to do";
    },

    liquidationPrice() {
      // if (this.pairValue) {
      //   let percent = parseFloat(
      //     (this.pairValue / this.maxPairValue) * 100
      //   ).toFixed(4);
      //
      //   return ((1 / this.tokenToUsd / 100) * percent).toFixed(2);
      // }
      if (!this.percentValue) return "xxx.xx";

      if (!this.mainValue && this.pairValue) {
        const liquidationPrice =
          (((+this.$store.getters.getUserBorrowPart(this.poolId) +
            +this.pairValue) *
            this.tokenToUsd) /
            +this.$store.getters.getUserCollateralShare(this.poolId)) *
          (1 / this.tokenToUsd) *
          this.liquidationMultiplier;

        return liquidationPrice;
      }

      if (this.mainValue && this.pairValue) {
        const liquidationPrice =
          (((+this.$store.getters.getUserBorrowPart(this.poolId) +
            +this.pairValue) *
            this.tokenToUsd) /
            (+this.$store.getters.getUserCollateralShare(this.poolId) +
              (parseFloat(this.mainValue) || 0))) *
          (1 / this.tokenToUsd) *
          this.liquidationMultiplier;

        return liquidationPrice;
      }

      // return ((1 / this.tokenToUsd / 100) * this.percentValue).toFixed(2);

      return "xxx.xx";
    },
  },
  methods: {
    getAVAXStatus() {
      return this.$store.getters.getUseAVAX;
    },
    updateMultiplier(newVal) {
      this.multiplier = newVal;
    },
    updateSlipage(newVal) {
      this.slipage = newVal;
    },
    toggleUpdatePrice() {
      this.updatePrice = !this.updatePrice;
    },
    toggleShowLeverage() {
      if (this.showLeverage === true) {
        this.multiplier = 1;
      }

      // this.showLeverage = !this.showLeverage;
    },
    toggleUseAVAX() {
      const AVAXStatus = this.$store.getters.getUseAVAX;
      this.$store.commit("setUseAVAX", !AVAXStatus);
    },
    toFixed(num, fixed) {
      // eslint-disable-next-line no-useless-escape
      let re = new RegExp(`^-?\\d+(?:\.\\d{0,` + (fixed || -1) + `})?`);
      return num.toString().match(re)[0];
    },
    actionHandler() {
      if (this.mainValue && this.pairValue && parseFloat(this.pairValue) > 0) {
        if (this.actionType === "borrow") {
          const parsedAmount = this.$ethers.utils.parseUnits(
            this.mainValue.toString(),
            this.mainValueDecimals
          );

          const parsedPair = this.$ethers.utils.parseUnits(
            this.toFixed(this.pairValue, 6),
            this.pairValueDecimals
          );

          const payload = {
            collateralAmount: parsedAmount,
            amount: parsedPair,
            updatePrice: this.updatePrice,
          };

          if (this.multiplier > 1) {
            payload.amount = this.toFixed(this.pairValue, 6);
            this.multiplierHandle(payload, "addAndBorrowMultiple");
            return false;
          }
          this.$emit("addAndBorrow", payload);
          this.clearData();
        }

        if (this.actionType === "repay") {
          let parsedAmount = this.$ethers.utils.parseUnits(
            this.toFixed(this.mainValue, 6),
            this.mainValueDecimals
          );
          let parsedPair = this.$ethers.utils.parseUnits(
            this.pairValue.toString(),
            this.pairValueDecimals
          );

          let payload = {
            collateralAmount: parsedAmount,
            amount: parsedPair,
            updatePrice: this.updatePrice,
          };

          if (
            this.mainValue === this.maxMainValue &&
            this.pairValue === this.maxPairValue
          ) {
            parsedAmount = this.$ethers.utils.parseUnits(
              this.userTotalBorrowed,
              this.mainValueDecimals
            );
            parsedPair = this.$ethers.utils.parseUnits(
              this.userTotalCollateral,
              this.pairValueDecimals
            );

            payload = {
              collateralAmount: parsedAmount,
              amount: parsedPair,
              updatePrice: this.updatePrice,
            };

            this.$emit("removeAndRepayMax", payload);
            this.clearData();
            return false;
          }

          this.$emit("removeAndRepay", payload);
          this.clearData();
        }
        return false;
      }

      if (this.mainValue) {
        if (this.actionType === "borrow") {
          const parsedAmount = this.$ethers.utils.parseUnits(
            this.mainValue.toString(),
            this.mainValueDecimals
          );

          const payload = {
            amount: parsedAmount,
            updatePrice: this.updatePrice,
          };

          this.$emit("addCollateral", payload);
          this.clearData();
        }
        if (this.actionType === "repay") {
          const parsedAmount = this.$ethers.utils.parseUnits(
            this.toFixed(this.mainValue, 6),
            this.mainValueDecimals
          );

          const payload = {
            amount: parsedAmount,
            updatePrice: this.updatePrice,
          };
          this.$emit("repay", payload);
          this.clearData();
        }
        return false;
      }

      if (this.pairValue) {
        if (this.actionType === "borrow") {
          const parsedPair = this.$ethers.utils.parseUnits(
            this.toFixed(this.pairValue, 6),
            this.pairValueDecimals
          );

          const payload = {
            amount: parsedPair,
            updatePrice: this.updatePrice,
          };

          if (this.multiplier > 1) {
            payload.amount = this.toFixed(this.pairValue, 6);
            this.multiplierHandle(payload, "borrowMultiple");
            return false;
          }

          this.$emit("borrow", payload);
          this.clearData();
        }
        if (this.actionType === "repay") {
          const parsedPair = this.$ethers.utils.parseUnits(
            this.pairValue.toString(),
            this.pairValueDecimals
          );

          const payload = {
            amount: parsedPair,
            updatePrice: this.updatePrice,
          };

          this.$emit("removeCollateral", payload);
          this.clearData();
        }

        return false;
      }
    },
    multiplierHandle(data, type) {
      const percentValue = parseFloat(this.percentValue);

      if (!percentValue) return false;

      console.log("percentValue", percentValue);
      console.log("DATA", data);

      const slipageMutiplier = (100 - this.slipage) / 100;

      console.log("slipageMutiplier", slipageMutiplier);

      const amountMultiplyer = percentValue / 100;

      let startAmount = data.amount * 0.995;
      let finalAmount = 0;

      for (let i = this.multiplier; i > 0; i--) {
        finalAmount += +startAmount;
        startAmount = startAmount * amountMultiplyer;
      }

      const mimAmount = this.$ethers.utils.parseUnits(
        this.toFixed(finalAmount, this.pairValueDecimals),
        this.pairValueDecimals
      );

      const minValue = finalAmount * this.tokenToUsd * slipageMutiplier;

      const minValueParsed = this.$ethers.utils.parseUnits(
        this.toFixed(minValue, this.mainValueDecimals),
        this.mainValueDecimals
      );

      console.log("finalAmount", finalAmount);
      console.log("minValue", minValue);

      const payload = {
        ...data,
        amount: mimAmount,
        minExpected: minValueParsed,
      };

      console.log("AMOUNT AFTER", type, mimAmount.toString());

      this.$emit(type, payload);
    },
    clearData() {
      this.mainValue = "";
      this.mainValueError = "";
      this.pairValue = "";
      this.pairValueError = "";
      this.percentValue = "";
    },
    updateMainValue(value) {
      this.mainValue = value;

      if (parseFloat(value) > parseFloat(this.maxMainValue)) {
        this.mainValueError = `Insufficient amount. The value available ${this.maxMainValue}`;
        return false;
      }

      this.mainValueError = "";

      if (this.actionType === "repay") {
        const collateralPercent = (this.pairValue / this.maxPairValue) * 100;
        const borrowPercent =
          (value / this.$store.getters.getUserBorrowPart(this.poolId)) * 100; //this.userTotalBorrowed

        const borrowedInDolarts =
          this.$store.getters.getUserBorrowPart(this.poolId) /
          this.tokenPairToUsd; //this.userTotalBorrowed
        const collateralInDolarts =
          this.$store.getters.getUserCollateralShare(this.poolId) /
          this.tokenToUsd; //this.userTotalCollateral
        const userHasDolars = collateralInDolarts - borrowedInDolarts;
        const acceptedPercent = (userHasDolars / collateralInDolarts) * 100;

        if (
          collateralPercent <= borrowPercent &&
          collateralPercent < acceptedPercent
        ) {
          this.pairValueError = "";
          return false;
        }
        this.pairValueError = `You have insufficient collateral. Please enter a smaller amount or repay more.`;
        return false;
      }

      if (this.pairValue) {
        this.updatePairValue(this.pairValue);
      }

      if (this.percentValue && value) {
        this.pairValue = (this.maxPairValue * this.percentValue) / this.ltv;
      }
    },
    updatePairValue(value) {
      if (parseFloat(value) > parseFloat(this.maxPairValue)) {
        this.pairValueError = `Insufficient amount. The value available ${this.maxPairValue}`;
        return false;
      }

      if (this.actionType === "repay") {
        if (!value) {
          this.pairValueError = "";
          this.pairValue = value;
        }

        const borrowedInDolarts =
          this.$store.getters.getUserBorrowPart(this.poolId) /
          this.tokenPairToUsd;
        const collateralInDolarts =
          this.$store.getters.getUserCollateralShare(this.poolId) /
          this.tokenToUsd;
        const userHasDolars = collateralInDolarts - borrowedInDolarts;
        const acceptedPercent = (userHasDolars / collateralInDolarts) * 100;

        const collateralPercent = (value / this.maxPairValue) * 100;
        const borrowPercent =
          (this.mainValue /
            this.$store.getters.getUserBorrowPart(this.poolId)) *
          100;
        if (
          acceptedPercent < collateralPercent &&
          collateralPercent > borrowPercent
        ) {
          this.pairValueError = `You have insufficient collateral. Please enter a smaller amount or repay more.`;
          this.pairValue = value;
          return false;
        }

        console.log(collateralPercent, borrowPercent);
        this.pairValueError = "";
        this.pairValue = value;

        return false;
      }

      this.pairValueError = "";
      this.pairValue = value;

      if (!value) {
        this.updatePercentValue("");
        return false;
      }

      this.updatePercentValue(
        parseFloat((this.pairValue / this.maxPairValue) * this.ltv).toFixed(4),
        true
      );
    },
    updatePercentValue(value, fromPair) {
      this.percentValue = value;

      if (fromPair) return false;

      if (this.mainValue && value) {
        this.pairValue = (this.maxPairValue * value) / this.ltv;
      }
    },
    async getUserBalance() {
      // const balance = await this.signer.getBalance();

      // const parsedBalance = this.$ethers.utils.formatUnits(balance.toString());

      const parsedBalance = this.$ethers.utils.formatUnits(
        this.balance.toString(),
        this.tokenDecimals
      );

      this.userBalance = parsedBalance;

      console.log("FORMAT BALANCE:", this.userBalance);

      if (this.balanceNativeToken) {
        const parsedBalanceNativeToken = this.$ethers.utils.formatEther(
          this.balanceNativeToken.toString()
        );

        this.userBalanceNativeToken = parsedBalanceNativeToken;

        console.log(
          "FORMAT BALANCE NATIVE TOKEN:",
          this.userBalanceNativeToken
        );
      }
    },
  },
  async created() {
    await this.getUserBalance();
  },
  components: {
    ValueInput,
    LiquidationRules,
    LeverageBar,
    EstimationBlock,
    SlipageBlock,
  },
};
</script>

<style scoped lang="scss">
.deposit-borrow-block {
  padding: 0 24px;
  background: $clrBg2;
  border-radius: 4px;
  width: 100%;

  .estimate-box {
    background: rgba(255, 255, 255, 0.02);
    border-radius: 4px;
    border: 1px solid #606060;
    padding: 16px 12px;
    margin-bottom: 8px;
  }
  .config-box {
    background: rgba(255, 255, 255, 0.02);
    border-radius: 4px;
    border: 1px solid #606060;
    padding: 20px;
    margin-bottom: 8px;
  }

  .checkbox-wrap {
    display: flex;
    align-items: center;
    font-size: 14px;
    line-height: 20px;

    .label-text {
      cursor: pointer;
    }

    .info-icon {
      width: 13px;
      height: 13px;
      margin-left: 5px;
    }

    .box-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      margin-right: 10px;
      background: rgba(255, 255, 255, 0.06);
      cursor: pointer;
      transition: all 0.1s ease;

      &:hover {
        //border: 1px solid $clrBlue;
      }

      &.active {
        .box {
          opacity: 1;
        }
      }

      &.disabled .checkbox {
        cursor: not-allowed;
        filter: brightness(0) saturate(100%) invert(61%) sepia(1%)
          saturate(2362%) hue-rotate(40deg) brightness(90%) contrast(83%);
      }

      .checkbox {
        height: 18px;
        width: 18px;
      }

      .checkbox-checked {
        filter: brightness(0) saturate(100%) invert(81%) sepia(54%)
          saturate(404%) hue-rotate(18deg) brightness(108%) contrast(98%);
      }

      .box {
        background: $clrBlue;
        border-radius: 4px;
        width: 12px;
        height: 12px;
        opacity: 0;
        transition: all 0.1s ease;
      }
    }
  }

  .action-wrap {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin: 16px 0 24px;
  }

  h3 {
    margin: 24px 0 16px;
    text-align: left;
    font-size: 16px;
    line-height: 24px;
  }

  .input-wrap {
    margin: 16px 0;
  }

  .action-btn {
    color: #000000;
    margin-left: auto;
    //width: auto;
    width: 200px;
    height: 32px;
  }

  .btn {
    &:disabled {
      color: $clrDisableText;
    }
  }
}

@media screen and(max-width: 780px) {
  .deposit-borrow-block {
    padding-left: 10px;
    padding-right: 10px;
  }

  .deposit-borrow-block .config-box {
    padding: 10px;
  }
}
</style>
